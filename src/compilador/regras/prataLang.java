/* Generated By:JavaCC: Do not edit this line. prataLang.java */
package compilador.regras;
import compilador.telas.CompiladorGui;
import java.io.*;
import java.util.HashMap;
import java.util.Objects;
import java.util.Stack;
import javax.swing.table.DefaultTableModel;

public class prataLang implements prataLangConstants {

  final static String Version = "PrataLang Compiler - Version 1.0 - 2024";
  boolean Menosshort = false;
  int countParseError = 0;
  String error_s = "";
  Integer pointer = 1;
  String context = "";

  int VT = 0, VP = 0;
  int tipo = 0;

  Stack pilha = new Stack<Integer>();
  Integer point = 1;
  Stack<String> memory = new Stack<String>(); //Pilha de memoria das funções
  HashMap instructionArea = new HashMap<Integer, InstructionArea>();
  HashMap simbolsTable = new HashMap<String, Auxst>();

  // Metodo que é chamado no CompiladorGui para compilar pelo botão e pelo menu
  public static void Compile(String file, prataLang parser, CompiladorGui gui) throws ParseException {
    boolean debug = false;
    String filename = file; // nome do arquivo a ser analizado
    boolean ms = false;

    gui.jTextArea1.append(Version + "\n");

    gui.jTextArea1.append("Readig from file " + filename + " . . .  \n");

    try {
      parser = new prataLang(new java.io.FileInputStream(filename));
    } catch (java.io.FileNotFoundException e) {
      gui.jTextArea1.append("File " + filename + " NOT FOUND \n");
      return;
    }

    if (!debug)
      parser.disable_tracing();

    parser.Menosshort = ms;

    try {
      parser.lex(gui);
      parser.ReInit(new java.io.FileInputStream(filename));
      if (parser.token_source.foundLexError() == 0) {
        parser.program(gui);
      }
    } catch (ParseException e) {
      parser.countParseError += 1;
    } catch (FileNotFoundException e) {
      throw new RuntimeException(e);
    } finally {
      if (parser.token_source.foundLexError() != 0) {
        gui.jTextArea1.append(
                parser.token_source.foundLexError() + " Lexic Error Found \n");

      } else if (parser.countParseError != 0) {
        gui.jTextArea1.append(parser.error_s + "\n");
        gui.jTextArea1.append(
                parser.countParseError + " Syntactic Errors found");
      } else
        gui.jTextArea1.append(" Successfully Analized Program \n");
    }

  }

  //metodo auxiliar
  static public String im(int x) {
    int k;
    String s;
    s = tokenImage[x];
    k = s.lastIndexOf("\"");
    try {
      s = s.substring(1, k);
    } catch (StringIndexOutOfBoundsException e) {
    }
    return s;
  }

  void lex(CompiladorGui gui) throws ParseException {
    trace_call("lex");
    try {
      Token t;
      do {
        t = getNextToken();
        Token st = t;
        while (st.specialToken != null)
          st = st.specialToken;
        do {
          if (token_source.eherro != 0) {
            if (!Menosshort) {
              gui.jTextArea1.append(token_source.error + st.kind + " " + im(st.kind) + "\n");
              token_source.error = "";
            } else {
              System.out.println(token_source.error + st.kind + " " + im(st.kind) + "\n");
              token_source.error = "";
            }
          }
          st = st.next;
        } while (st != t.next);
      } while (t.kind != prataLangConstants.EOF);
      if (token_source.curLexState == 1) {
        gui.jTextArea1.append(" Error to end Block Comment \n");
        token_source.countLexError++;
      }
    } finally {
      trace_return("lex");
    }
  }

  final public void program(CompiladorGui gui) throws ParseException {
    trace_call("program");
    try {
      try {
        jj_consume_token(MAKE);
      } catch (Exception e) {
        gui.jTextArea1.append("Line: " + token_source.input_stream.getBeginLine() + " Column: "
                + (token_source.input_stream.getBeginColumn() - 1) + " Expected: Make" + "\n");
        countParseError += 1;
      }
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case IDENT:
          jj_consume_token(IDENT);
          two(gui);
          break;
        default:
          jj_la1[0] = jj_gen;
          ;
      }
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case CONST:
        case VAR:
          declaracao(gui);
          break;
        default:
          jj_la1[1] = jj_gen;
          ;
      }
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case GET:
        case PUT:
        case IF:
        case WHILE:
        case NOT:
        case int_constant:
        case char_constant:
        case float_constant:
        case TRUE:
        case FALSE:
        case IDENT:
        case LPAREN:
          listacomandos(gui);
          break;
        default:
          jj_la1[2] = jj_gen;
          ;
      }
      try {
        jj_consume_token(END);
      } catch (Exception e) {
        gui.jTextArea1.append("Line: " + token_source.input_stream.getBeginLine() + " Column: "
                + (token_source.input_stream.getBeginColumn() - 1) + " Expected: End" + "\n");
        countParseError += 1;
      }
      try {
        jj_consume_token(DOT);
      } catch (Exception e) {
        gui.jTextArea1.append("Line: " + token_source.input_stream.getBeginLine() + " Column: "
                + (token_source.input_stream.getBeginColumn() - 1) + " Expected: Dot" + "\n");
        countParseError += 1;
      }
      one(gui);
    } finally {
      trace_return("program");
    }
  }

  final public void declaracao(CompiladorGui gui) throws ParseException {
    trace_call("declaracao");
    try {
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case VAR:
          declaracaoV(gui);
          switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case CONST:
              declaracaoC(gui);
              break;
            default:
              jj_la1[3] = jj_gen;
              ;
          }
          break;
        case CONST:
          declaracaoC(gui);
          switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case VAR:
              declaracaoV(gui);
              break;
            default:
              jj_la1[4] = jj_gen;
              ;
          }
          break;
        default:
          jj_la1[5] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
      }
    } finally {
      trace_return("declaracao");
    }
  }

  final public void declaracaoC(CompiladorGui gui) throws ParseException {
    trace_call("declaracaoC");
    try {
      try {
        jj_consume_token(CONST);
      } catch (Exception e) {
        gui.jTextArea1.append("Line: " + token_source.input_stream.getBeginLine() + " Column: "
                + (token_source.input_stream.getBeginColumn() - 1) + " Expected: Constant" + "\n");
        countParseError += 1;
      }
      three(gui);
      listadeconstante(gui);
      try {
        jj_consume_token(END);
      } catch (Exception e) {
        gui.jTextArea1.append("Line: " + token_source.input_stream.getBeginLine() + " Column: "
                + (token_source.input_stream.getBeginColumn() - 1) + " Expected: End" + "\n");
        countParseError += 1;
      }
      try {
        jj_consume_token(SEMICOLON);
      } catch (Exception e) {
        gui.jTextArea1.append("Line: " + token_source.input_stream.getBeginLine() + " Column: "
                + (token_source.input_stream.getBeginColumn() - 1) + " Expected: Semicolon" + "\n");
        countParseError += 1;
      }
    } finally {
      trace_return("declaracaoC");
    }
  }

  final public void listadeconstante(CompiladorGui gui) throws ParseException {
    trace_call("listadeconstante");
    try {
      tipoC(gui);
      try {
        jj_consume_token(TWO_POINTS);
      } catch (Exception e) {
        gui.jTextArea1.append("Line: " + token_source.input_stream.getBeginLine() + " Column: "
                + (token_source.input_stream.getBeginColumn() - 1) + " Expected: Two Points (:)" + "\n");
        countParseError += 1;
      }
      listadeident(gui);
      four(gui);
      try {
        jj_consume_token(EQUAL);
      } catch (Exception e) {
        gui.jTextArea1.append("Line: " + token_source.input_stream.getBeginLine() + " Column: "
                + (token_source.input_stream.getBeginColumn() - 1) + " Expected: Equals (=)" + "\n");
        countParseError += 1;
      }
      valor(gui);
      five(gui);
      try {
        jj_consume_token(DOT);
      } catch (Exception e) {
        gui.jTextArea1.append("Line: " + token_source.input_stream.getBeginLine() + " Column: "
                + (token_source.input_stream.getBeginColumn() - 1) + " Expected: Dot" + "\n");
        countParseError += 1;
      }
      _listadeconstante(gui);
    } finally {
      trace_return("listadeconstante");
    }
  }

  final public void _listadeconstante(CompiladorGui gui) throws ParseException {
    trace_call("_listadeconstante");
    try {
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case INT:
        case REAL:
        case CHAR:
          listadeconstante(gui);
          break;
        default:
          jj_la1[6] = jj_gen;
          ;
      }
    } finally {
      trace_return("_listadeconstante");
    }
  }

  final public void tipoC(CompiladorGui gui) throws ParseException {
    trace_call("tipoC");
    try {
      try {
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
          case INT:
            jj_consume_token(INT);
            seven(gui);
            break;
          case REAL:
            jj_consume_token(REAL);
            eight(gui);
            break;
          case CHAR:
            jj_consume_token(CHAR);
            nine(gui);
            break;
          default:
            jj_la1[7] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
      } catch (Exception e) {
        gui.jTextArea1.append("Line: " + token_source.input_stream.getBeginLine() + " Column: "
                + (token_source.input_stream.getBeginColumn() - 1) + " Expected: Int, Real or Char" + "\n");
        countParseError += 1;
      }
    } finally {
      trace_return("tipoC");
    }
  }

  final public void listadeident(CompiladorGui gui) throws ParseException {
    trace_call("listadeident");
    try {
      try {
        jj_consume_token(IDENT);
        eleven(gui);
        _listadeident(gui);
      } catch (Exception e) {
        gui.jTextArea1.append("Line: " + token_source.input_stream.getBeginLine() + " Column: "
                + (token_source.input_stream.getBeginColumn() - 1) + " Expected: Identifier" + "\n");
        countParseError += 1;
      }
    } finally {
      trace_return("listadeident");
    }
  }

  final public void _listadeident(CompiladorGui gui) throws ParseException {
    trace_call("_listadeident");
    try {
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case COMMA:
          jj_consume_token(COMMA);
          listadeident(gui);
          break;
        default:
          jj_la1[8] = jj_gen;
          ;
      }
    } finally {
      trace_return("_listadeident");
    }
  }

  final public void valor(CompiladorGui gui) throws ParseException {
    trace_call("valor");
    try {
      try {
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
          case int_constant:
            jj_consume_token(int_constant);
            break;
          case float_constant:
            jj_consume_token(float_constant);
            break;
          case char_constant:
            jj_consume_token(char_constant);
            break;
          default:
            jj_la1[9] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
      } catch (Exception e) {
        gui.jTextArea1.append("Line: " + token_source.input_stream.getBeginLine() + " Column: "
                + (token_source.input_stream.getBeginColumn() - 1) + " Expected: Values" + "\n");
        countParseError += 1;
      }
    } finally {
      trace_return("valor");
    }
  }

  final public void declaracaoV(CompiladorGui gui) throws ParseException {
    trace_call("declaracaoV");
    try {
      try {
        jj_consume_token(VAR);
      } catch (Exception e) {
        gui.jTextArea1.append("Line: " + token_source.input_stream.getBeginLine() + " Column: "
                + (token_source.input_stream.getBeginColumn() - 1) + " Expected: Var" + "\n");
        countParseError += 1;
      }
      six(gui);
      listadevariavel(gui);
      try {
        jj_consume_token(END);
      } catch (Exception e) {
        gui.jTextArea1.append("Line: " + token_source.input_stream.getBeginLine() + " Column: "
                + (token_source.input_stream.getBeginColumn() - 1) + " Expected: End" + "\n");
        countParseError += 1;
      }
      try {
        jj_consume_token(SEMICOLON);
      } catch (Exception e) {
        gui.jTextArea1.append("Line: " + token_source.input_stream.getBeginLine() + " Column: "
                + (token_source.input_stream.getBeginColumn() - 1) + " Expected: Semicolon" + "\n");
        countParseError += 1;
      }
    } finally {
      trace_return("declaracaoV");
    }
  }

  final public void listadevariavel(CompiladorGui gui) throws ParseException {
    trace_call("listadevariavel");
    try {
      tipoV(gui);
      try {
        jj_consume_token(TWO_POINTS);
      } catch (Exception e) {
        gui.jTextArea1.append("Line: " + token_source.input_stream.getBeginLine() + " Column: "
                + (token_source.input_stream.getBeginColumn() - 1) + " Expected: Two Points (:)" + "\n");
        countParseError += 1;
      }
      listadeident(gui);
      four(gui);
      try {
        jj_consume_token(DOT);
      } catch (Exception e) {
        gui.jTextArea1.append("Line: " + token_source.input_stream.getBeginLine() + " Column: "
                + (token_source.input_stream.getBeginColumn() - 1) + " Expected: Dot" + "\n");
        countParseError += 1;
      }
      _listadevariavel(gui);
    } finally {
      trace_return("listadevariavel");
    }
  }

  final public void _listadevariavel(CompiladorGui gui) throws ParseException {
    trace_call("_listadevariavel");
    try {
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case INT:
        case REAL:
        case CHAR:
        case BOOL:
          listadevariavel(gui);
          break;
        default:
          jj_la1[10] = jj_gen;
          ;
      }
    } finally {
      trace_return("_listadevariavel");
    }
  }

  final public void tipoV(CompiladorGui gui) throws ParseException {
    trace_call("tipoV");
    try {
      try {
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
          case INT:
            jj_consume_token(INT);
            seven(gui);
            break;
          case REAL:
            jj_consume_token(REAL);
            eight(gui);
            break;
          case CHAR:
            jj_consume_token(CHAR);
            nine(gui);
            break;
          case BOOL:
            jj_consume_token(BOOL);
            ten(gui);
            break;
          default:
            jj_la1[11] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
      } catch (Exception e) {
        gui.jTextArea1.append("Line: " + token_source.input_stream.getBeginLine() + " Column: "
                + (token_source.input_stream.getBeginColumn() - 1) + " Expected: Int, Real, Char or Bool" + "\n");
        countParseError += 1;
      }
    } finally {
      trace_return("tipoV");
    }
  }

  final public void comandoatribuaicao(CompiladorGui gui) throws ParseException {
    trace_call("comandoatribuaicao");
    try {
      expressao(gui);
      try {
        jj_consume_token(ASSIGN);
      } catch (Exception e) {
        gui.jTextArea1.append("Line: " + token_source.input_stream.getBeginLine() + " Column: "
                + (token_source.input_stream.getBeginColumn() - 1) + " Expected: Assign (->)" + "\n");
        countParseError += 1;
      }
      try {
        jj_consume_token(IDENT);
      } catch (Exception e) {
        gui.jTextArea1.append("Line: " + token_source.input_stream.getBeginLine() + " Column: "
                + (token_source.input_stream.getBeginColumn() - 1) + " Expected: Identifier" + "\n");
        countParseError += 1;
      }
      twelve(gui);
      try {
        jj_consume_token(DOT);
      } catch (Exception e) {
        gui.jTextArea1.append("Line: " + token_source.input_stream.getBeginLine() + " Column: "
                + (token_source.input_stream.getBeginColumn() - 1) + " Expected: Dot" + "\n");
        countParseError += 1;
      }
    } finally {
      trace_return("comandoatribuaicao");
    }
  }

  final public void comandoentrada(CompiladorGui gui) throws ParseException {
    trace_call("comandoentrada");
    try {
      try {
        jj_consume_token(GET);
      } catch (Exception e) {
        gui.jTextArea1.append("Line: " + token_source.input_stream.getBeginLine() + " Column: "
                + (token_source.input_stream.getBeginColumn() - 1) + " Expected: Get" + "\n");
        countParseError += 1;
      }
      thirteen(gui);
      try {
        jj_consume_token(LPAREN);
      } catch (Exception e) {
        gui.jTextArea1.append("Line: " + token_source.input_stream.getBeginLine() + " Column: "
                + (token_source.input_stream.getBeginColumn() - 1) + " Expected: Left Parenthesis" + "\n");
        countParseError += 1;
      }
      listadeident(gui);
      try {
        jj_consume_token(RPAREN);
      } catch (Exception e) {
        gui.jTextArea1.append("Line: " + token_source.input_stream.getBeginLine() + " Column: "
                + (token_source.input_stream.getBeginColumn() - 1) + " Expected: Right Parenthesis" + "\n");
        countParseError += 1;
      }
      try {
        jj_consume_token(DOT);
      } catch (Exception e) {
        gui.jTextArea1.append("Line: " + token_source.input_stream.getBeginLine() + " Column: "
                + (token_source.input_stream.getBeginColumn() - 1) + " Expected: Dot" + "\n");
        countParseError += 1;
      }
    } finally {
      trace_return("comandoentrada");
    }
  }

  final public void comandosaida(CompiladorGui gui) throws ParseException {
    trace_call("comandosaida");
    try {
      try {
        jj_consume_token(PUT);
      } catch (Exception e) {
        gui.jTextArea1.append("Line: " + token_source.input_stream.getBeginLine() + " Column: "
                + (token_source.input_stream.getBeginColumn() - 1) + " Expected: Put" + "\n");
        countParseError += 1;
      }
      try {
        jj_consume_token(LPAREN);
      } catch (Exception e) {
        gui.jTextArea1.append("Line: " + token_source.input_stream.getBeginLine() + " Column: "
                + (token_source.input_stream.getBeginColumn() - 1) + " Expected: Left Parenthesis" + "\n");
        countParseError += 1;
      }
      listadeidenteconst(gui);
      try {
        jj_consume_token(RPAREN);
      } catch (Exception e) {
        gui.jTextArea1.append("Line: " + token_source.input_stream.getBeginLine() + " Column: "
                + (token_source.input_stream.getBeginColumn() - 1) + " Expected: Right Parenthesis" + "\n");
        countParseError += 1;
      }
      try {
        jj_consume_token(DOT);
      } catch (Exception e) {
        gui.jTextArea1.append("Line: " + token_source.input_stream.getBeginLine() + " Column: "
                + (token_source.input_stream.getBeginColumn() - 1) + " Expected: Dot" + "\n");
        countParseError += 1;
      }
    } finally {
      trace_return("comandosaida");
    }
  }

  final public void listadeidenteconst(CompiladorGui gui) throws ParseException {
    trace_call("listadeidenteconst");
    try {
      try {
        lic(gui);
        fourteen(gui);
        label_1:
        while (true) {
          switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case COMMA:
              ;
              break;
            default:
              jj_la1[12] = jj_gen;
              break label_1;
          }
          jj_consume_token(COMMA);
          lic(gui);
        }
      } catch (Exception e) {
        gui.jTextArea1.append("Line: " + token_source.input_stream.getBeginLine() + " Column: "
                + (token_source.input_stream.getBeginColumn() - 1) + " Expected: Comma" + "\n");
        countParseError += 1;
      }
    } finally {
      trace_return("listadeidenteconst");
    }
  }

  final public void lic(CompiladorGui gui) throws ParseException {
    trace_call("lic");
    try {
      try {
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
          case IDENT:
            jj_consume_token(IDENT);
            fifteen(gui);
            break;
          case int_constant:
            jj_consume_token(int_constant);
            sixteen(gui);
            break;
          case float_constant:
            jj_consume_token(float_constant);
            seventeen(gui);
            break;
          case char_constant:
            jj_consume_token(char_constant);
            eighteen(gui);
            break;
          case TRUE:
            jj_consume_token(TRUE);
            nineteen(gui);
            break;
          case FALSE:
            jj_consume_token(FALSE);
            twenty(gui);
            break;
          default:
            jj_la1[13] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
      } catch (Exception e) {
        gui.jTextArea1.append("Line: " + token_source.input_stream.getBeginLine() + " Column: "
                + (token_source.input_stream.getBeginColumn() - 1) + " Expected: Identifier or Const Type" + "\n");
        countParseError += 1;
      }
    } finally {
      trace_return("lic");
    }
  }

  final public void comandoselecao(CompiladorGui gui) throws ParseException {
    trace_call("comandoselecao");
    try {
      try {
        jj_consume_token(IF);
      } catch (Exception e) {
        gui.jTextArea1.append("Line: " + token_source.input_stream.getBeginLine() + " Column: "
                + (token_source.input_stream.getBeginColumn() - 1) + " Expected: If" + "\n");
        countParseError += 1;
      }
      expressao(gui);
      twentyone(gui);
      try {
        jj_consume_token(THEN);
      } catch (Exception e) {
        gui.jTextArea1.append("Line: " + token_source.input_stream.getBeginLine() + " Column: "
                + (token_source.input_stream.getBeginColumn() - 1) + " Expected: Then" + "\n");
        countParseError += 1;
      }
      listacomandos(gui);
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case ELSE:
          jj_consume_token(ELSE);
          twentythree(gui);
          listacomandos(gui);
          break;
        default:
          jj_la1[14] = jj_gen;
          ;
      }
      try {
        jj_consume_token(END);
      } catch (Exception e) {
        gui.jTextArea1.append("Line: " + token_source.input_stream.getBeginLine() + " Column: "
                + (token_source.input_stream.getBeginColumn() - 1) + " Expected: End" + "\n");
        countParseError += 1;
      }
      twentytwo(gui);
      try {
        jj_consume_token(DOT);
      } catch (Exception e) {
        gui.jTextArea1.append("Line: " + token_source.input_stream.getBeginLine() + " Column: "
                + (token_source.input_stream.getBeginColumn() - 1) + " Expected: Dot" + "\n");
        countParseError += 1;
      }
    } finally {
      trace_return("comandoselecao");
    }
  }

  final public void comandorepeticao(CompiladorGui gui) throws ParseException {
    trace_call("comandorepeticao");
    try {
      try {
        jj_consume_token(WHILE);
      } catch (Exception e) {
        gui.jTextArea1.append("Line: " + token_source.input_stream.getBeginLine() + " Column: "
                + (token_source.input_stream.getBeginColumn() - 1) + " Expected: While" + "\n");
        countParseError += 1;
      }
      twentyfour(gui);
      expressao(gui);
      twentyfive(gui);
      try {
        jj_consume_token(DO);
      } catch (Exception e) {
        gui.jTextArea1.append("Line: " + token_source.input_stream.getBeginLine() + " Column: "
                + (token_source.input_stream.getBeginColumn() - 1) + " Expected: Do" + "\n");
        countParseError += 1;
      }
      listacomandos(gui);
      try {
        jj_consume_token(END);
      } catch (Exception e) {
        gui.jTextArea1.append("Line: " + token_source.input_stream.getBeginLine() + " Column: "
                + (token_source.input_stream.getBeginColumn() - 1) + " Expected: End" + "\n");
        countParseError += 1;
      }
      twentysix(gui);
      try {
        jj_consume_token(DOT);
      } catch (Exception e) {
        gui.jTextArea1.append("Line: " + token_source.input_stream.getBeginLine() + " Column: "
                + (token_source.input_stream.getBeginColumn() - 1) + " Expected: Dot" + "\n");
        countParseError += 1;
      }
    } finally {
      trace_return("comandorepeticao");
    }
  }

  final public void listacomandos(CompiladorGui gui) throws ParseException {
    trace_call("listacomandos");
    try {
      comandos(gui);
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case GET:
        case PUT:
        case IF:
        case WHILE:
        case NOT:
        case int_constant:
        case char_constant:
        case float_constant:
        case TRUE:
        case FALSE:
        case IDENT:
        case LPAREN:
          listacomandos(gui);
          break;
        default:
          jj_la1[15] = jj_gen;
          ;
      }
    } finally {
      trace_return("listacomandos");
    }
  }

  final public void comandos(CompiladorGui gui) throws ParseException {
    trace_call("comandos");
    try {
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case NOT:
        case int_constant:
        case char_constant:
        case float_constant:
        case TRUE:
        case FALSE:
        case IDENT:
        case LPAREN:
          comandoatribuaicao(gui);
          break;
        case GET:
          comandoentrada(gui);
          break;
        case WHILE:
          comandorepeticao(gui);
          break;
        case PUT:
          comandosaida(gui);
          break;
        case IF:
          comandoselecao(gui);
          break;
        default:
          jj_la1[16] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
      }
    } finally {
      trace_return("comandos");
    }
  }

  final public void elemento(CompiladorGui gui) throws ParseException {
    trace_call("elemento");
    try {
      try {
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
          case IDENT:
            jj_consume_token(IDENT);
            fifteen(gui);
            break;
          case int_constant:
            jj_consume_token(int_constant);
            sixteen(gui);
            break;
          case float_constant:
            jj_consume_token(float_constant);
            seventeen(gui);
            break;
          case char_constant:
            jj_consume_token(char_constant);
            eighteen(gui);
            break;
          case TRUE:
            jj_consume_token(TRUE);
            nineteen(gui);
            break;
          case FALSE:
            jj_consume_token(FALSE);
            twenty(gui);
            break;
          case NOT:
            jj_consume_token(NOT);
            jj_consume_token(LPAREN);
            expressao(gui);
            jj_consume_token(RPAREN);
            fourtytwo(gui);
            break;
          case LPAREN:
            jj_consume_token(LPAREN);
            expressao(gui);
            jj_consume_token(RPAREN);
            break;
          default:
            jj_la1[17] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
      } catch (Exception e) {
        gui.jTextArea1.append("Line: " + token_source.input_stream.getBeginLine() + " Column: "
                + (token_source.input_stream.getBeginColumn() - 1) + " Expected: Element" + "\n");
        countParseError += 1;
      }
    } finally {
      trace_return("elemento");
    }
  }

  final public void expressao(CompiladorGui gui) throws ParseException {
    trace_call("expressao");
    try {
      expressaoaroulo(gui);
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case EQUAL:
        case DIFFERENT:
        case MINOR:
        case MINOR_EQUAL:
        case BIGGER:
        case BIGGER_EQUAL:
          _expressao(gui);
          break;
        default:
          jj_la1[18] = jj_gen;
          ;
      }
    } finally {
      trace_return("expressao");
    }
  }

  final public void _expressao(CompiladorGui gui) throws ParseException {
    trace_call("_expressao");
    try {
      try {
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
          case EQUAL:
            jj_consume_token(EQUAL);
            expressaoaroulo(gui);
            twentyseven(gui);
            break;
          case DIFFERENT:
            jj_consume_token(DIFFERENT);
            expressaoaroulo(gui);
            twentyeight(gui);
            break;
          case BIGGER:
            jj_consume_token(BIGGER);
            expressaoaroulo(gui);
            thirty(gui);
            break;
          case MINOR:
            jj_consume_token(MINOR);
            expressaoaroulo(gui);
            twentynine(gui);
            break;
          case BIGGER_EQUAL:
            jj_consume_token(BIGGER_EQUAL);
            expressaoaroulo(gui);
            thirtytwo(gui);
            break;
          case MINOR_EQUAL:
            jj_consume_token(MINOR_EQUAL);
            expressaoaroulo(gui);
            thirtyone(gui);
            break;
          default:
            jj_la1[19] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
      } catch (Exception e) {
        gui.jTextArea1.append("Line: " + token_source.input_stream.getBeginLine() + " Column: "
                + (token_source.input_stream.getBeginColumn() - 1) + " Expected: Arithmetic or Logical operators" + "\n");
        countParseError += 1;
      }
    } finally {
      trace_return("_expressao");
    }
  }

  final public void expressaoaroulo(CompiladorGui gui) throws ParseException {
    trace_call("expressaoaroulo");
    try {
      termo2(gui);
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case OR:
        case PLUS:
        case MINUS:
          menorP(gui);
          break;
        default:
          jj_la1[20] = jj_gen;
          ;
      }
    } finally {
      trace_return("expressaoaroulo");
    }
  }

  final public void menorP(CompiladorGui gui) throws ParseException {
    trace_call("menorP");
    try {
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case PLUS:
          jj_consume_token(PLUS);
          termo2(gui);
          thirtythree(gui);
          switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case OR:
            case PLUS:
            case MINUS:
              menorP(gui);
              break;
            default:
              jj_la1[21] = jj_gen;
              ;
          }
          break;
        case MINUS:
          jj_consume_token(MINUS);
          termo2(gui);
          thirtyfour(gui);
          switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case OR:
            case PLUS:
            case MINUS:
              menorP(gui);
              break;
            default:
              jj_la1[22] = jj_gen;
              ;
          }
          break;
        case OR:
          jj_consume_token(OR);
          termo2(gui);
          thirtyfive(gui);
          switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case OR:
            case PLUS:
            case MINUS:
              menorP(gui);
              break;
            default:
              jj_la1[23] = jj_gen;
              ;
          }
          break;
        default:
          jj_la1[24] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
      }
    } finally {
      trace_return("menorP");
    }
  }

  final public void termo2(CompiladorGui gui) throws ParseException {
    trace_call("termo2");
    try {
      termo1(gui);
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case END_LOGIC:
        case MULTIPLICATION:
        case DIVISION:
        case ENTIRE_DIVISION:
        case DIVISION_REST:
          mediaP(gui);
          break;
        default:
          jj_la1[25] = jj_gen;
          ;
      }
    } finally {
      trace_return("termo2");
    }
  }

  final public void mediaP(CompiladorGui gui) throws ParseException {
    trace_call("mediaP");
    try {
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case MULTIPLICATION:
          jj_consume_token(MULTIPLICATION);
          termo1(gui);
          thirtysix(gui);
          switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case END_LOGIC:
            case MULTIPLICATION:
            case DIVISION:
            case ENTIRE_DIVISION:
            case DIVISION_REST:
              mediaP(gui);
              break;
            default:
              jj_la1[26] = jj_gen;
              ;
          }
          break;
        case DIVISION:
          jj_consume_token(DIVISION);
          termo1(gui);
          thirtyseven(gui);
          switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case END_LOGIC:
            case MULTIPLICATION:
            case DIVISION:
            case ENTIRE_DIVISION:
            case DIVISION_REST:
              mediaP(gui);
              break;
            default:
              jj_la1[27] = jj_gen;
              ;
          }
          break;
        case ENTIRE_DIVISION:
          jj_consume_token(ENTIRE_DIVISION);
          termo1(gui);
          thirtyeight(gui);
          switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case END_LOGIC:
            case MULTIPLICATION:
            case DIVISION:
            case ENTIRE_DIVISION:
            case DIVISION_REST:
              mediaP(gui);
              break;
            default:
              jj_la1[28] = jj_gen;
              ;
          }
          break;
        case DIVISION_REST:
          jj_consume_token(DIVISION_REST);
          termo1(gui);
          thirtynine(gui);
          switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case END_LOGIC:
            case MULTIPLICATION:
            case DIVISION:
            case ENTIRE_DIVISION:
            case DIVISION_REST:
              mediaP(gui);
              break;
            default:
              jj_la1[29] = jj_gen;
              ;
          }
          break;
        case END_LOGIC:
          jj_consume_token(END_LOGIC);
          termo1(gui);
          fourty(gui);
          switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case END_LOGIC:
            case MULTIPLICATION:
            case DIVISION:
            case ENTIRE_DIVISION:
            case DIVISION_REST:
              mediaP(gui);
              break;
            default:
              jj_la1[30] = jj_gen;
              ;
          }
          break;
        default:
          jj_la1[31] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
      }
    } finally {
      trace_return("mediaP");
    }
  }

  final public void termo1(CompiladorGui gui) throws ParseException {
    trace_call("termo1");
    try {
      elemento(gui);
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case POTENCY:
          maiorP(gui);
          break;
        default:
          jj_la1[32] = jj_gen;
          ;
      }
    } finally {
      trace_return("termo1");
    }
  }

  final public void maiorP(CompiladorGui gui) throws ParseException {
    trace_call("maiorP");
    try {
      jj_consume_token(POTENCY);
      fourtyone(gui);
      termo1(gui);
    } finally {
      trace_return("maiorP");
    }
  }

  final private void one(CompiladorGui gui) throws ParseException {
    trace_call("one");
    try {
      InstructionArea instruction = new InstructionArea("STP", "0");
      instructionArea.put(pointer, instruction);
      String columns[] = {"Number", "Code", "Parameter"};
      int size = instructionArea.size();
      String Data[][] = new String[size][3];
      InstructionArea in;
      for (int i = 1; i <= instructionArea.size(); i++) {
        int j = i - 1;
        in = (InstructionArea) instructionArea.get(i);
        Data[j][0] = String.valueOf(i);
        Data[j][1] = in.getInstruction();
        Data[j][2] = String.valueOf(in.getParameter());
      }
      DefaultTableModel model = new DefaultTableModel(Data, columns);
      gui.tabela.jTable1.setModel(model);
      for(point = 0; point <= Data.length;) {
        System.out.println(point);
        switch (Data[point][1]) {
          case "ADD":
            ADD(gui);
            break;
          case "SUB":
            SUB();
            break;
          case "MUL":
            MUL();
            break;
          case "DIV":
            DIV(gui);
            break;
          case "ALB":
            ALB(Integer.valueOf(Data[point][2]));
            break;
          case "ALI":
            ALI(Integer.valueOf(Data[point][2]));
            break;
          case "ALR":
            ALR(gui, Integer.valueOf(Data[point][2]));
            break;
          case "AND":
            AND();
            break;
          case "OR":
            OR();
            break;
          case "ALS":
            ALS(Integer.valueOf(Data[point][2]));
            break;
          case "BGE":
            BGE(gui);
            break;
          case "BGR":
            BGR(gui);
            break;
          case "DIF":
            DIF();
            break;
          case "EQL":
            EQL();
            break;
          case "JMF":
            JMF(Integer.valueOf(Data[point][2]));
            break;
          case "JMP":
            JMP(Integer.valueOf(Data[point][2]));
            break;
          case "JMT":
            JMT(gui, Integer.valueOf(Data[point][2]));
            break;
          case "LDV":
            LDV(gui, Integer.valueOf(Data[point][2]));
            break;
          case "LDB":
            LDB(gui, Boolean.valueOf(Data[point][2]));
            break;
          case "LDI":
            LDI(gui, Integer.valueOf(Data[point][2]));
            break;
          case "LDR":
            LDR(gui, Float.valueOf(Data[point][2]));
            break;
          case "LDS":
            LDS(Data[point][2]);
            break;
          case "NOT":
            NOT();
            break;
          case "REA":
            REA(gui, Integer.valueOf(Data[point][2]));
            break;
          case "SME":
            SME(gui);
            break;
          case "SMR":
            SMR(gui);
            break;
          case "STR":
            STR(gui, Integer.valueOf(Data[point][2]));
            break;
          case "STP":
            STP(gui);
            point = Data.length + 1;
            break;
          case "WRT":
            WRT(gui);
            break;
          case "STC":
            STC(Integer.valueOf(Data[point][2]));
            break;
        }
      }
      jj_consume_token(0);
    } finally {
      trace_return("one");
    }
  }

  final private void two(CompiladorGui gui) throws ParseException {
    trace_call("two");
    try {
      Auxst auxst = new Auxst(0); //category e atributo
      simbolsTable.put(token, auxst);
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case INVALID_LEXICAL:
          jj_consume_token(INVALID_LEXICAL);
          break;
        default:
          jj_la1[33] = jj_gen;
          ;
      }
    } finally {
      trace_return("two");
    }
  }

  final private void three(CompiladorGui gui) throws ParseException {
    trace_call("three");
    try {
      context = "const";
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case INVALID_LEXICAL:
          jj_consume_token(INVALID_LEXICAL);
          break;
        default:
          jj_la1[34] = jj_gen;
          ;
      }
    } finally {
      trace_return("three");
    }
  }

  final private void four(CompiladorGui gui) throws ParseException {
    trace_call("four");
    try {
      if (tipo == 1 || tipo == 5) {
        InstructionArea instruction = new InstructionArea("ALI", String.valueOf(VP));
        instructionArea.put(pointer, instruction);
        pointer++;
      } else if (tipo == 2 || tipo == 6) {
        InstructionArea instruction = new InstructionArea("ALR", String.valueOf(VP));
        instructionArea.put(pointer, instruction);
        pointer++;
      } else if (tipo == 3 || tipo == 7) {
        InstructionArea instruction = new InstructionArea("ALS", String.valueOf(VP));
        instructionArea.put(pointer, instruction);
        pointer++;
      } else if (tipo == 4) {
        InstructionArea instruction = new InstructionArea("ALB", String.valueOf(VP));
        instructionArea.put(pointer, instruction);
        pointer++;
      }
      if (tipo == 1 || tipo == 2 || tipo == 3 || tipo == 4) {
        VP = 1;
      }
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case INVALID_LEXICAL:
          jj_consume_token(INVALID_LEXICAL);
          break;
        default:
          jj_la1[35] = jj_gen;
          ;
      }
    } finally {
      trace_return("four");
    }
  }

  final private void five(CompiladorGui gui) throws ParseException {
    trace_call("five");
    try {
      switch (tipo) {
        case 5:
          InstructionArea instruction = new InstructionArea("LDI", token.image);
          instructionArea.put(pointer, instruction);
          pointer++;
          break;
        case 6:
          InstructionArea instruction1 = new InstructionArea("LDR", token.image);
          instructionArea.put(pointer, instruction1);
          pointer++;
          break;
        case 7:
          InstructionArea instruction2 = new InstructionArea("LDS", token.image);
          instructionArea.put(pointer, instruction2);
          pointer++;
          break;
      }
      InstructionArea instruction3 = new InstructionArea("STC", String.valueOf(VP));
      instructionArea.put(pointer, instruction3);
      pointer++;
      VP = 1;
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case INVALID_LEXICAL:
          jj_consume_token(INVALID_LEXICAL);
          break;
        default:
          jj_la1[36] = jj_gen;
          ;
      }
    } finally {
      trace_return("five");
    }
  }

  final private void six(CompiladorGui gui) throws ParseException {
    trace_call("six");
    try {
      context = "var";
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case INVALID_LEXICAL:
          jj_consume_token(INVALID_LEXICAL);
          break;
        default:
          jj_la1[37] = jj_gen;
          ;
      }
    } finally {
      trace_return("six");
    }
  }

  final private void seven(CompiladorGui gui) throws ParseException {
    trace_call("seven");
    try {
      if (context == "var") {
        tipo = 1;
      } else {
        tipo = 5;
      }
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case INVALID_LEXICAL:
          jj_consume_token(INVALID_LEXICAL);
          break;
        default:
          jj_la1[38] = jj_gen;
          ;
      }
    } finally {
      trace_return("seven");
    }
  }

  final private void eight(CompiladorGui gui) throws ParseException {
    trace_call("eight");
    try {
      if (context == "var") {
        tipo = 2;
      } else {
        tipo = 6;
      }
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case INVALID_LEXICAL:
          jj_consume_token(INVALID_LEXICAL);
          break;
        default:
          jj_la1[39] = jj_gen;
          ;
      }
    } finally {
      trace_return("eight");
    }
  }

  final private void nine(CompiladorGui gui) throws ParseException {
    trace_call("nine");
    try {
      if (context == "var") {
        tipo = 3;
      } else {
        tipo = 7;
      }
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case INVALID_LEXICAL:
          jj_consume_token(INVALID_LEXICAL);
          break;
        default:
          jj_la1[40] = jj_gen;
          ;
      }
    } finally {
      trace_return("nine");
    }
  }

  final private void ten(CompiladorGui gui) throws ParseException {
    trace_call("ten");
    try {
      tipo = 4;
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case INVALID_LEXICAL:
          jj_consume_token(INVALID_LEXICAL);
          break;
        default:
          jj_la1[41] = jj_gen;
          ;
      }
    } finally {
      trace_return("ten");
    }
  }

  final private void eleven(CompiladorGui gui) throws ParseException {
    trace_call("eleven");
    try {
      if (context == "const" || context == "var") {
        if (simbolsTable.containsKey(token.image)) {
          gui.jTextArea1.append("Identifier already declared \n");
        } else {
          VT++;
          VP++;
          simbolsTable.put(token.image, new Auxst(tipo, VT));

        }
      } else if (Objects.equals(context, "data entry")) {
        if (simbolsTable.containsKey(token.image)) {
          Auxst aux = (Auxst) simbolsTable.get(token.image);
          if (aux.getCategory() == 1 || aux.getCategory() == 2 || aux.getCategory() == 3 || aux.getCategory() == 4) {
            InstructionArea instruction = new InstructionArea("REA", String.valueOf(aux.getCategory()));
            instructionArea.put(pointer, instruction);
            pointer++;
            InstructionArea instruction2 = new InstructionArea("STR", String.valueOf(aux.getAttribute()));
            instructionArea.put(pointer, instruction2);
            pointer++;
          } else {
            gui.jTextArea1.append("Program or Constant Identifier\n");
          }
        } else {
          System.out.println("Identifier not declared");
        }
      }
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case INVALID_LEXICAL:
          jj_consume_token(INVALID_LEXICAL);
          break;
        default:
          jj_la1[42] = jj_gen;
          ;
      }
    } finally {
      trace_return("eleven");
    }
  }

  final private void twelve(CompiladorGui gui) throws ParseException {
    trace_call("twelve");
    try {
      if (simbolsTable.containsKey(token.image)) {
        Auxst aux = (Auxst) simbolsTable.get(token.image);
        if (aux.getCategory() == 1 || aux.getCategory() == 2 || aux.getCategory() == 3 || aux.getCategory() == 4) {
          InstructionArea instruction2 = new InstructionArea("STR", String.valueOf(aux.getAttribute()));
          instructionArea.put(pointer, instruction2);
          pointer++;
        } else {
          gui.jTextArea1.append("Program or Constant Identifier\n");
        }
      } else {
        gui.jTextArea1.append("Identifier not declared\n");
      }
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case INVALID_LEXICAL:
          jj_consume_token(INVALID_LEXICAL);
          break;
        default:
          jj_la1[43] = jj_gen;
          ;
      }
    } finally {
      trace_return("twelve");
    }
  }

  final private void thirteen(CompiladorGui gui) throws ParseException {
    trace_call("thirteen");
    try {
      context = "data entry";
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case INVALID_LEXICAL:
          jj_consume_token(INVALID_LEXICAL);
          break;
        default:
          jj_la1[44] = jj_gen;
          ;
      }
    } finally {
      trace_return("thirteen");
    }
  }

  final private void fourteen(CompiladorGui gui) throws ParseException {
    trace_call("fourteen");
    try {
      InstructionArea instruction = new InstructionArea("WRT", "0");
      instructionArea.put(pointer, instruction);
      pointer++;
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case INVALID_LEXICAL:
          jj_consume_token(INVALID_LEXICAL);
          break;
        default:
          jj_la1[45] = jj_gen;
          ;
      }
    } finally {
      trace_return("fourteen");
    }
  }

  final private void fifteen(CompiladorGui gui) throws ParseException {
    trace_call("fifteen");
    try {
      if (simbolsTable.containsKey(token.image)) {
        Auxst aux = (Auxst) simbolsTable.get(token.image);
        if (aux.getCategory() == 1 || aux.getCategory() == 2 || aux.getCategory() == 3 || aux.getCategory() == 4
                || aux.getCategory() == 5 || aux.getCategory() == 6 || aux.getCategory() == 7) {
          InstructionArea instruction2 = new InstructionArea("LDV", String.valueOf(aux.getAttribute()));
          instructionArea.put(pointer, instruction2);
          pointer++;
        } else {
          gui.jTextArea1.append("Program or Constant Identifier\n");
        }
      } else {
        gui.jTextArea1.append("Identifier not declared\n");
      }
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case INVALID_LEXICAL:
          jj_consume_token(INVALID_LEXICAL);
          break;
        default:
          jj_la1[46] = jj_gen;
          ;
      }
    } finally {
      trace_return("fifteen");
    }
  }

  final private void sixteen(CompiladorGui gui) throws ParseException {
    trace_call("sixteen");
    try {
      InstructionArea instruction = new InstructionArea("LDI", token.image);
      instructionArea.put(pointer, instruction);
      pointer++;
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case INVALID_LEXICAL:
          jj_consume_token(INVALID_LEXICAL);
          break;
        default:
          jj_la1[47] = jj_gen;
          ;
      }
    } finally {
      trace_return("sixteen");
    }
  }

  final private void seventeen(CompiladorGui gui) throws ParseException {
    trace_call("seventeen");
    try {
      InstructionArea instruction = new InstructionArea("LDR", token.image);
      instructionArea.put(pointer, instruction);
      pointer++;
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case INVALID_LEXICAL:
          jj_consume_token(INVALID_LEXICAL);
          break;
        default:
          jj_la1[48] = jj_gen;
          ;
      }
    } finally {
      trace_return("seventeen");
    }
  }

  final private void eighteen(CompiladorGui gui) throws ParseException {
    trace_call("eighteen");
    try {
      InstructionArea instruction = new InstructionArea("LDS", token.image);
      instructionArea.put(pointer, instruction);
      pointer++;
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case INVALID_LEXICAL:
          jj_consume_token(INVALID_LEXICAL);
          break;
        default:
          jj_la1[49] = jj_gen;
          ;
      }
    } finally {
      trace_return("eighteen");
    }
  }

  final private void nineteen(CompiladorGui gui) throws ParseException {
    trace_call("nineteen");
    try {
      InstructionArea instruction = new InstructionArea("LDB", "true");
      instructionArea.put(pointer, instruction);
      pointer++;
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case INVALID_LEXICAL:
          jj_consume_token(INVALID_LEXICAL);
          break;
        default:
          jj_la1[50] = jj_gen;
          ;
      }
    } finally {
      trace_return("nineteen");
    }
  }

  final private void twenty(CompiladorGui gui) throws ParseException {
    trace_call("twenty");
    try {
      InstructionArea instruction = new InstructionArea("LDB", "false");
      instructionArea.put(pointer, instruction);
      pointer++;
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case INVALID_LEXICAL:
          jj_consume_token(INVALID_LEXICAL);
          break;
        default:
          jj_la1[51] = jj_gen;
          ;
      }
    } finally {
      trace_return("twenty");
    }
  }

  final private void twentyone(CompiladorGui gui) throws ParseException {
    trace_call("twentyone");
    try {
      InstructionArea instruction = new InstructionArea("JMF", "0");
      instructionArea.put(pointer, instruction);
      pilha.add(pointer);
      pointer++;
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case INVALID_LEXICAL:
          jj_consume_token(INVALID_LEXICAL);
          break;
        default:
          jj_la1[52] = jj_gen;
          ;
      }
    } finally {
      trace_return("twentyone");
    }
  }

  final private void twentytwo(CompiladorGui gui) throws ParseException {
    trace_call("twentytwo");
    try {
      Integer aux = (Integer) pilha.pop();
      InstructionArea i = (InstructionArea) instructionArea.get(aux);
      i.setParameter(String.valueOf(pointer));
      instructionArea.replace(aux, i);
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case INVALID_LEXICAL:
          jj_consume_token(INVALID_LEXICAL);
          break;
        default:
          jj_la1[53] = jj_gen;
          ;
      }
    } finally {
      trace_return("twentytwo");
    }
  }

  final private void twentythree(CompiladorGui gui) throws ParseException {
    trace_call("twentythree");
    try {
      Integer aux = (Integer) pilha.pop();
      InstructionArea i = (InstructionArea) instructionArea.get(aux);
      i.setParameter(String.valueOf(pointer));
      instructionArea.replace(aux, i);
      InstructionArea instruction = new InstructionArea("JMP", "0");
      instructionArea.put(pointer, instruction);
      pilha.add(pointer);
      pointer++;
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case INVALID_LEXICAL:
          jj_consume_token(INVALID_LEXICAL);
          break;
        default:
          jj_la1[54] = jj_gen;
          ;
      }
    } finally {
      trace_return("twentythree");
    }
  }

  final private void twentyfour(CompiladorGui gui) throws ParseException {
    trace_call("twentyfour");
    try {
      pilha.add(pointer);
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case INVALID_LEXICAL:
          jj_consume_token(INVALID_LEXICAL);
          break;
        default:
          jj_la1[55] = jj_gen;
          ;
      }
    } finally {
      trace_return("twentyfour");
    }
  }

  final private void twentyfive(CompiladorGui gui) throws ParseException {
    trace_call("twentyfive");
    try {
      InstructionArea instruction = new InstructionArea("JMF", "0");
      instructionArea.put(pointer, instruction);
      pilha.add(pointer);
      pointer++;
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case INVALID_LEXICAL:
          jj_consume_token(INVALID_LEXICAL);
          break;
        default:
          jj_la1[56] = jj_gen;
          ;
      }
    } finally {
      trace_return("twentyfive");
    }
  }

  final private void twentysix(CompiladorGui gui) throws ParseException {
    trace_call("twentysix");
    try {
      Integer aux = (Integer) pilha.pop();
      InstructionArea i = (InstructionArea) instructionArea.get(aux);
      i.setParameter(String.valueOf(pointer+1));
      instructionArea.replace(aux, i);
      Integer aux2 = (Integer) pilha.pop();
      InstructionArea instruction = new InstructionArea("JMP", String.valueOf(aux2));
      instructionArea.put(pointer, instruction);
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case INVALID_LEXICAL:
          jj_consume_token(INVALID_LEXICAL);
          break;
        default:
          jj_la1[57] = jj_gen;
          ;
      }
    } finally {
      trace_return("twentysix");
    }
  }

  final private void twentyseven(CompiladorGui gui) throws ParseException {
    trace_call("twentyseven");
    try {
      InstructionArea instruction = new InstructionArea("EQL", "0");
      instructionArea.put(pointer, instruction);
      pointer++;
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case INVALID_LEXICAL:
          jj_consume_token(INVALID_LEXICAL);
          break;
        default:
          jj_la1[58] = jj_gen;
          ;
      }
    } finally {
      trace_return("twentyseven");
    }
  }

  final private void twentyeight(CompiladorGui gui) throws ParseException {
    trace_call("twentyeight");
    try {
      InstructionArea instruction = new InstructionArea("DIF", "0");
      instructionArea.put(pointer, instruction);
      pointer++;
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case INVALID_LEXICAL:
          jj_consume_token(INVALID_LEXICAL);
          break;
        default:
          jj_la1[59] = jj_gen;
          ;
      }
    } finally {
      trace_return("twentyeight");
    }
  }

  final private void twentynine(CompiladorGui gui) throws ParseException {
    trace_call("twentynine");
    try {
      InstructionArea instruction = new InstructionArea("SMR", "0");
      instructionArea.put(pointer, instruction);
      pointer++;
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case INVALID_LEXICAL:
          jj_consume_token(INVALID_LEXICAL);
          break;
        default:
          jj_la1[60] = jj_gen;
          ;
      }
    } finally {
      trace_return("twentynine");
    }
  }

  final private void thirty(CompiladorGui gui) throws ParseException {
    trace_call("thirty");
    try {
      InstructionArea instruction = new InstructionArea("BGR", "0");
      instructionArea.put(pointer, instruction);
      pointer++;
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case INVALID_LEXICAL:
          jj_consume_token(INVALID_LEXICAL);
          break;
        default:
          jj_la1[61] = jj_gen;
          ;
      }
    } finally {
      trace_return("thirty");
    }
  }

  final private void thirtyone(CompiladorGui gui) throws ParseException {
    trace_call("thirtyone");
    try {
      InstructionArea instruction = new InstructionArea("SME", "0");
      instructionArea.put(pointer, instruction);
      pointer++;
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case INVALID_LEXICAL:
          jj_consume_token(INVALID_LEXICAL);
          break;
        default:
          jj_la1[62] = jj_gen;
          ;
      }
    } finally {
      trace_return("thirtyone");
    }
  }

  final private void thirtytwo(CompiladorGui gui) throws ParseException {
    trace_call("thirtytwo");
    try {
      InstructionArea instruction = new InstructionArea("BGE", "0");
      instructionArea.put(pointer, instruction);
      pointer++;
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case INVALID_LEXICAL:
          jj_consume_token(INVALID_LEXICAL);
          break;
        default:
          jj_la1[63] = jj_gen;
          ;
      }
    } finally {
      trace_return("thirtytwo");
    }
  }

  final private void thirtythree(CompiladorGui gui) throws ParseException {
    trace_call("thirtythree");
    try {
      InstructionArea instruction = new InstructionArea("ADD", "0");
      instructionArea.put(pointer, instruction);
      pointer++;
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case INVALID_LEXICAL:
          jj_consume_token(INVALID_LEXICAL);
          break;
        default:
          jj_la1[64] = jj_gen;
          ;
      }
    } finally {
      trace_return("thirtythree");
    }
  }

  final private void thirtyfour(CompiladorGui gui) throws ParseException {
    trace_call("thirtyfour");
    try {
      InstructionArea instruction = new InstructionArea("SUB", "0");
      instructionArea.put(pointer, instruction);
      pointer++;
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case INVALID_LEXICAL:
          jj_consume_token(INVALID_LEXICAL);
          break;
        default:
          jj_la1[65] = jj_gen;
          ;
      }
    } finally {
      trace_return("thirtyfour");
    }
  }

  final private void thirtyfive(CompiladorGui gui) throws ParseException {
    trace_call("thirtyfive");
    try {
      InstructionArea instruction = new InstructionArea("OR", "0");
      instructionArea.put(pointer, instruction);
      pointer++;
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case INVALID_LEXICAL:
          jj_consume_token(INVALID_LEXICAL);
          break;
        default:
          jj_la1[66] = jj_gen;
          ;
      }
    } finally {
      trace_return("thirtyfive");
    }
  }

  final private void thirtysix(CompiladorGui gui) throws ParseException {
    trace_call("thirtysix");
    try {
      InstructionArea instruction = new InstructionArea("MUL", "0");
      instructionArea.put(pointer, instruction);
      pointer++;
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case INVALID_LEXICAL:
          jj_consume_token(INVALID_LEXICAL);
          break;
        default:
          jj_la1[67] = jj_gen;
          ;
      }
    } finally {
      trace_return("thirtysix");
    }
  }

  final private void thirtyseven(CompiladorGui gui) throws ParseException {
    trace_call("thirtyseven");
    try {
      InstructionArea instruction = new InstructionArea("DIV", "0");
      instructionArea.put(pointer, instruction);
      pointer++;
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case INVALID_LEXICAL:
          jj_consume_token(INVALID_LEXICAL);
          break;
        default:
          jj_la1[68] = jj_gen;
          ;
      }
    } finally {
      trace_return("thirtyseven");
    }
  }

  final private void thirtyeight(CompiladorGui gui) throws ParseException {
    trace_call("thirtyeight");
    try {
      InstructionArea instruction = new InstructionArea("IDIV", "0");
      instructionArea.put(pointer, instruction);
      pointer++;
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case INVALID_LEXICAL:
          jj_consume_token(INVALID_LEXICAL);
          break;
        default:
          jj_la1[69] = jj_gen;
          ;
      }
    } finally {
      trace_return("thirtyeight");
    }
  }

  final private void thirtynine(CompiladorGui gui) throws ParseException {
    trace_call("thirtynine");
    try {
      InstructionArea instruction = new InstructionArea("MOD", "0");
      instructionArea.put(pointer, instruction);
      pointer++;
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case INVALID_LEXICAL:
          jj_consume_token(INVALID_LEXICAL);
          break;
        default:
          jj_la1[70] = jj_gen;
          ;
      }
    } finally {
      trace_return("thirtynine");
    }
  }

  final private void fourty(CompiladorGui gui) throws ParseException {
    trace_call("fourty");
    try {
      InstructionArea instruction = new InstructionArea("AND", "0");
      instructionArea.put(pointer, instruction);
      pointer++;
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case INVALID_LEXICAL:
          jj_consume_token(INVALID_LEXICAL);
          break;
        default:
          jj_la1[71] = jj_gen;
          ;
      }
    } finally {
      trace_return("fourty");
    }
  }

  final private void fourtyone(CompiladorGui gui) throws ParseException {
    trace_call("fourtyone");
    try {
      InstructionArea instruction = new InstructionArea("POW", "0");
      instructionArea.put(pointer, instruction);
      pointer++;
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case INVALID_LEXICAL:
          jj_consume_token(INVALID_LEXICAL);
          break;
        default:
          jj_la1[72] = jj_gen;
          ;
      }
    } finally {
      trace_return("fourtyone");
    }
  }

  final private void fourtytwo(CompiladorGui gui) throws ParseException {
    trace_call("fourtytwo");
    try {
      InstructionArea instruction = new InstructionArea("NOT", "0");
      instructionArea.put(pointer, instruction);
      pointer++;
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case INVALID_LEXICAL:
          jj_consume_token(INVALID_LEXICAL);
          break;
        default:
          jj_la1[73] = jj_gen;
          ;
      }
    } finally {
      trace_return("fourtytwo");
    }
  }

  /**
   * Generated Token Manager.
   */
  public prataLangTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /**
   * Current token.
   */
  public Token token;
  /**
   * Next token.
   */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[74];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;

  static {
    jj_la1_init_0();
    jj_la1_init_1();
  }

  private static void jj_la1_init_0() {
    jj_la1_0 = new int[]{0x0, 0x84000, 0xa700000, 0x4000, 0x80000, 0x84000, 0x38000, 0x38000, 0x0, 0x0, 0x78000,
            0x78000, 0x0, 0x0, 0x1000000, 0xa700000, 0xa700000, 0x8000000, 0x80000000, 0x80000000, 0x10000000, 0x10000000,
            0x10000000, 0x10000000, 0x10000000, 0x20000000, 0x20000000, 0x20000000, 0x20000000, 0x20000000, 0x20000000,
            0x20000000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,};
  }

  private static void jj_la1_init_1() {
    jj_la1_1 = new int[]{0x40000, 0x0, 0x85f000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x100000, 0x7000, 0x0, 0x0, 0x100000,
            0x5f000, 0x0, 0x85f000, 0x85f000, 0x85f000, 0x1f, 0x1f, 0x60, 0x60, 0x60, 0x60, 0x60, 0xd80, 0xd80, 0xd80,
            0xd80, 0xd80, 0xd80, 0xd80, 0x200, 0x2000000, 0x2000000, 0x2000000, 0x2000000, 0x2000000, 0x2000000, 0x2000000,
            0x2000000, 0x2000000, 0x2000000, 0x2000000, 0x2000000, 0x2000000, 0x2000000, 0x2000000, 0x2000000, 0x2000000,
            0x2000000, 0x2000000, 0x2000000, 0x2000000, 0x2000000, 0x2000000, 0x2000000, 0x2000000, 0x2000000, 0x2000000,
            0x2000000, 0x2000000, 0x2000000, 0x2000000, 0x2000000, 0x2000000, 0x2000000, 0x2000000, 0x2000000, 0x2000000,
            0x2000000, 0x2000000, 0x2000000, 0x2000000,};
  }

  /**
   * Constructor with InputStream.
   */
  public prataLang(java.io.InputStream stream) {
    this(stream, null);
  }

  /**
   * Constructor with InputStream and supplied encoding
   */
  public prataLang(java.io.InputStream stream, String encoding) {
    try {
      jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1);
    } catch (java.io.UnsupportedEncodingException e) {
      throw new RuntimeException(e);
    }
    token_source = new prataLangTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 74; i++)
      jj_la1[i] = -1;
  }

  /**
   * Reinitialise.
   */
  public void ReInit(java.io.InputStream stream) {
    ReInit(stream, null);
  }

  /**
   * Reinitialise.
   */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try {
      jj_input_stream.ReInit(stream, encoding, 1, 1);
    } catch (java.io.UnsupportedEncodingException e) {
      throw new RuntimeException(e);
    }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 74; i++)
      jj_la1[i] = -1;
  }

  /**
   * Constructor.
   */
  public prataLang(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new prataLangTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 74; i++)
      jj_la1[i] = -1;
  }

  /**
   * Reinitialise.
   */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 74; i++)
      jj_la1[i] = -1;
  }

  /**
   * Constructor with generated Token Manager.
   */
  public prataLang(prataLangTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 74; i++)
      jj_la1[i] = -1;
  }

  /**
   * Reinitialise.
   */
  public void ReInit(prataLangTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 74; i++)
      jj_la1[i] = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null)
      token = token.next;
    else
      token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      trace_token(token, "");
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  /**
   * Get the next Token.
   */
  final public Token getNextToken() {
    if (token.next != null)
      token = token.next;
    else
      token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    trace_token(token, " (in getNextToken)");
    return token;
  }

  /**
   * Get the specific Token.
   */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null)
        t = t.next;
      else
        t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt = token.next) == null)
      return (jj_ntk = (token.next = token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List jj_expentries = new java.util.ArrayList();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /**
   * Generate ParseException.
   */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[64];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 74; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1 << j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1 << j)) != 0) {
            la1tokens[32 + j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 64; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[]) jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  private int trace_indent = 0;
  private boolean trace_enabled = true;

  /**
   * Enable tracing.
   */
  final public void enable_tracing() {
    trace_enabled = true;
  }

  /**
   * Disable tracing.
   */
  final public void disable_tracing() {
    trace_enabled = false;
  }

  private void trace_call(String s) {
    if (trace_enabled) {
      for (int i = 0; i < trace_indent; i++) {
        System.out.print(" ");
      }
      System.out.println("Call:   " + s);
    }
    trace_indent = trace_indent + 2;
  }

  private void trace_return(String s) {
    trace_indent = trace_indent - 2;
    if (trace_enabled) {
      for (int i = 0; i < trace_indent; i++) {
        System.out.print(" ");
      }
      System.out.println("Return: " + s);
    }
  }

  private void trace_token(Token t, String where) {
    if (trace_enabled) {
      for (int i = 0; i < trace_indent; i++) {
        System.out.print(" ");
      }
      System.out.print("Consumed token: <" + tokenImage[t.kind]);
      if (t.kind != 0 && !tokenImage[t.kind].equals("\"" + t.image + "\"")) {
        System.out.print(": \"" + t.image + "\"");
      }
      System.out.println(" at line " + t.beginLine + " column " + t.beginColumn + ">" + where);
    }
  }

  private void ADD(CompiladorGui gui) {
    //gui.TextArea.append("Uau"); // escrever no console
    Integer aux = Integer.valueOf(memory.pop());
    aux += Integer.valueOf(memory.pop());
    memory.add(String.valueOf(aux));
    point++;
  }

  private void ALR(CompiladorGui gui, Integer deslocamento) {

    int size = memory.size();
    for (int i = size; i < deslocamento; i++) {
      memory.add(String.valueOf(0.0));

    }
    //topo = topo+deslocamento;
    point++;
  }

  private void ALB(Integer deslocamento) {
    int size = memory.size();
    for (int i = size; i < deslocamento; i++) {
      memory.add(String.valueOf(false));
    }
    // topo = topo+deslocamento;
    point++;

  }

  private void ALS(Integer deslocamento) {
    int size = memory.size();
    for (int i = size; i < deslocamento; i++) {
      memory.add("");
    }
    //topo = topo+deslocamento;
    point++;
  }

  private void ALI(Integer deslocamento) {
    int size = memory.size();
    for (int i = size; i < deslocamento; i++) {
      memory.add(String.valueOf(0));
    }
    //topo = topo+deslocamento;
    point++;
  }

  private void AND() {
    // gui.TextArea.append("Uau"); // escrever no console
    boolean aux = Boolean.valueOf(memory.pop());
    Boolean bool = aux && Boolean.valueOf(memory.pop());

    memory.add(String.valueOf(bool));
    point++;
  }

  private void BGE(CompiladorGui gui) {
    Integer aux = Integer.valueOf(memory.pop());
    Boolean bool = aux >= Integer.valueOf(memory.pop());

    memory.add(String.valueOf(bool));
    point++;
  }

  private void BGR(CompiladorGui gui) {
    Integer aux = Integer.valueOf(memory.pop());
    Boolean bool = aux > Integer.valueOf(memory.pop());

    memory.add(String.valueOf(bool));
    point++;
  }

  private void LDS(String constante) {
    memory.add(String.valueOf(constante));
    point++;
  }

  private void DIF() {
    Integer aux = Integer.valueOf(memory.pop());
    Boolean bool = aux != Integer.valueOf(memory.pop());

    memory.add(String.valueOf(bool));
    point++;
  }

  private void MUL() {
    Integer aux = Integer.valueOf(memory.pop());
    Integer mul = aux * Integer.valueOf(memory.pop());

    memory.add(String.valueOf(mul));
    point++;
  }

  private void DIV(CompiladorGui gui) {

    Float topo = Float.valueOf(memory.getLast());
    if (topo == 0) {
      gui.jTextArea1.append("'RUNTIME error: divisão por 0 \n");
    } else {
      Float aux = Float.valueOf(memory.pop());
      Float div = aux / Float.valueOf(memory.pop());

      memory.add(String.valueOf(div));

    }
    point++;

  }

  private void NOT() {
    Boolean aux = Boolean.valueOf(memory.pop());
    Boolean mul = !aux;

    memory.add(String.valueOf(mul));
    point++;
  }

  private void OR() {
    Boolean aux = Boolean.valueOf(memory.pop());
    Boolean mul = aux || Boolean.valueOf(memory.pop());

    memory.add(String.valueOf(mul));
    point++;
  }

  public void EQL() {
    Integer aux = Integer.valueOf(memory.pop());
    Boolean mul = aux.equals(Integer.valueOf(memory.pop()));

    memory.add(String.valueOf(mul));
    point++;
  }

  public void JMF(Integer Endereco) {
    Boolean topoValor = Boolean.valueOf(memory.pop());
    if (!topoValor) {
      point = Endereco;
    } else {
      point++;
    }
    // topo--;
  }

  public void JMP(Integer Endereco) {
    point = Endereco;
  }

  private void JMT(CompiladorGui gui, int endereco) {
    Boolean topoValor = Boolean.valueOf(memory.pop());
    if (topoValor) {
      point = endereco;
    } else {
      point++;
    }
    // topo--;
  }

  private void LDV(CompiladorGui gui, int endereco) {
    String valor = memory.get(endereco);
    memory.add(valor);
    point++;
  }

  private void LDB(CompiladorGui gui, boolean constante) {
    memory.add(String.valueOf(constante));
    point++;
  }

  private void LDI(CompiladorGui gui, int constante) {
    memory.add(String.valueOf(constante));
    point++;
  }

  private void LDR(CompiladorGui gui, double constante) {
    memory.add(String.valueOf(constante));
    point++;
  }

  private void REA(CompiladorGui gui, int tipo) {

    point++;
    String entrada = "Uau";

    if (!isTipoValido(entrada, tipo)) {
      gui.jTextArea1.append("RUNTIME error\n");
      ParseException pe = generateParseException();
      throw new RuntimeException(pe);
    }

    memory.add(entrada);
  }

  private void SME(CompiladorGui gui) {
    Integer valor2 = Integer.valueOf(memory.pop());
    Integer valor1 = Integer.valueOf(memory.pop());

    Boolean resultado = valor2 <= valor1;

    memory.add(String.valueOf(resultado));

    point++;
  }

  private void SMR(CompiladorGui gui) {
    Integer valor2 = Integer.valueOf(memory.pop());
    Integer valor1 = Integer.valueOf(memory.pop());

    Boolean resultado = valor1 < valor2;

    memory.add(String.valueOf(resultado));

    point++;
  }

  private void STR(CompiladorGui gui, int endereco) {
    String valor = memory.pop();

    memory.set(endereco, valor);

    pointer++;
  }

  private void STP(CompiladorGui gui) {

  }

  private void WRT(CompiladorGui gui) {
    gui.jTextArea1.append(String.valueOf(memory.pop()) + "\n");
    point++;
  }

  private void SUB() {
    Integer aux = Integer.valueOf(memory.pop());
    aux -= Integer.valueOf(memory.pop());
    memory.add(String.valueOf(aux));
    point++;
  }

  private void STC(Integer deslocamento) {
    String aux = memory.getLast();
    for (int i = 0; i <= deslocamento; i++) {
      memory.set(i, aux);
    }
    //topo = topo+deslocamento;
    point++;
  }

  private void POW() {
    Integer expoente = Integer.valueOf(memory.pop());
    Integer base = Integer.valueOf(memory.pop());
    Double pow = Math.pow(base, expoente);

    memory.add(String.valueOf(pow.intValue()));
    point++;
  }

  private void MOD(CompiladorGui gui) {
    Integer topo = Integer.valueOf(memory.getLast());
    if (topo == 0) {
      gui.jTextArea1.append("'RUNTIME error: divisão por 0\n");
    } else {
      Integer aux = Integer.valueOf(memory.pop());
      Integer mod = aux % Integer.valueOf(memory.pop());

      memory.add(String.valueOf(mod));
    }
    point++;
  }

  private void IDIV(CompiladorGui gui) {
    // Verifica o divisor para evitar divisão por zero
    Integer divisor = Integer.valueOf(memory.getLast());
    if (divisor == 0) {
      gui.jTextArea1.append("'RUNTIME error: divisão por 0\n");
    } else {
      // Realiza a divisão inteira
      Integer dividendo = Integer.valueOf(memory.pop());
      Integer resultado = dividendo / Integer.valueOf(memory.pop());

      // Adiciona o resultado como inteiro na memória
      memory.add(String.valueOf(resultado));
    }
    point++;
  }


  private boolean isTipoValido(String entrada, int tipo) {
    try {
      switch (tipo) {
        case 1:
          Integer.parseInt(entrada);
          break;
        case 2:
          Double.parseDouble(entrada);
          break;
        case 3:
          if (!entrada.equals("true") && !entrada.equals("false")) return false;
          break;
        default:
          return false;
      }
      return true;
    } catch (Exception e) {
      return false;
    }
  }


  private void trace_scan(Token t1, int t2) {
    if (trace_enabled) {
      for (int i = 0; i < trace_indent; i++) {
        System.out.print(" ");
      }
      System.out.print("Visited token: <" + tokenImage[t1.kind]);
      if (t1.kind != 0 && !tokenImage[t1.kind].equals("\"" + t1.image + "\"")) {
        System.out.print(": \"" + t1.image + "\"");
      }
      System.out.println(
              " at line " + t1.beginLine + " column " + t1.beginColumn + ">; Expected token: <" + tokenImage[t2] + ">");
    }
  }
}
